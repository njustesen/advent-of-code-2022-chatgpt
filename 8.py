"""
Solves https://adventofcode.com/2022/day/8.
Part 1: First three attempts were close. Fourth solved it.
Part 2: Got close in first attempt. I used a few additional prompts to improve it, e.g. to exclude trees on the edge. 
Finally, I had to modify two of the iterators.
"""

# Part 1

# Read the input data
with open('8.txt') as file:
  data = file.readlines()

# Parse the input data into a grid
grid = []
for line in data:
  grid.append([int(x) for x in line.strip()])

# Function to check if a tree is visible
def is_visible(row, col, grid):
  # Check if the tree is visible from the left
  for i in range(col):
    if grid[row][i] >= grid[row][col]:
      break
  else:
    return True

  # Check if the tree is visible from the right
  for i in range(col+1, len(grid[0])):
    if grid[row][i] >= grid[row][col]:
      break
  else:
    return True

  # Check if the tree is visible from the top
  for i in range(row):
    if grid[i][col] >= grid[row][col]:
      break
  else:
    return True

  # Check if the tree is visible from the bottom
  for i in range(row+1, len(grid)):
    if grid[i][col] >= grid[row][col]:
      break
  else:
    return True

  # If none of the above checks returned True, the tree is not visible
  return False

# Count the number of visible trees
count = 0
for row in range(len(grid)):
  for col in range(len(grid[0])):
    if is_visible(row, col, grid):
      count += 1

# Print the result
print(count)


# Part 2

# Read the input data
with open('8.txt') as file:
  data = file.readlines()

# Parse the input data into a grid
grid = []
for line in data:
  grid.append([int(x) for x in line.strip()])

# Function to calculate the scenic score of a tree
def scenic_score(row, col, grid):

  # Return 0 if the tree is at the edge of the grid
  if row == 0 or row == len(grid) - 1 or col == 0 or col == len(grid[0]) - 1:  # Generated by ChatGPT in a second prompt 
    return 0
  
  # Initialize the scenic score to 1
  score = 1

  # Function to count the number of visible trees in a given direction
  def count_trees(row, col, direction, grid):
    # Initialize the counter
    count = 0

    # Check if the tree is visible in this direction
    if direction == 'up':
      for i in range(row-1, -1, -1):  # Added a -1
        count += 1
        if grid[i][col] >= grid[row][col]:
          break
    elif direction == 'down':
      for i in range(row+1, len(grid)):
        count += 1
        if grid[i][col] >= grid[row][col]:
          break
        
    elif direction == 'left':
      for i in range(col-1, -1, -1):  # Added a -1
        count += 1
        if grid[row][i] >= grid[row][col]:
          break
        
    elif direction == 'right':
      for i in range(col+1, len(grid[0])):
        count += 1
        if grid[row][i] >= grid[row][col]:
          break
        
    # Return the count of visible trees
    return count

  # Count the number of visible trees in each direction
  for direction in ['up', 'down', 'left', 'right']:
    # Multiply the scenic score by the number of visible trees in this direction
    score *= (count_trees(row, col, direction, grid))

  # Return the scenic score
  return score

# Initialize variables to keep track of the highest scenic score and the tree with that score
max_score = 0
max_tree = None

# Iterate through each tree in the grid
for row in range(len(grid)):
  for col in range(len(grid[0])):
    # Calculate the scenic score of this tree
    score = scenic_score(row, col, grid)

    # Update the maximum scenic score and tree with that score, if necessary
    if score > max_score:
      max_score = score
      max_tree = (row, col)

# Print the result
print(f'The tree with the highest scenic score is at {max_tree[0]},{max_tree[1]} with a score of {max_score}.')
